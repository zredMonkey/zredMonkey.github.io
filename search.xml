<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>异步注解（@EnableAsync和@Async）</title>
      <link href="/%E5%BC%82%E6%AD%A5%E6%B3%A8%E8%A7%A3%EF%BC%88@EnableAsync%E5%92%8C@Async%EF%BC%89/"/>
      <url>/%E5%BC%82%E6%AD%A5%E6%B3%A8%E8%A7%A3%EF%BC%88@EnableAsync%E5%92%8C@Async%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用？"><a href="#为什么要使用？" class="headerlink" title="为什么要使用？"></a>为什么要使用？</h1><p>1.在我们的日常开发中，我们偶尔会遇到在业务层中我们需要同时修改多张表的数据并且需要有序的执行，如果我们用往常的同步的方式，也就是单线程的方式来执行的话，可能会出现执行超时等异常造成请求结果失败，即使成功，前端也需要等待较长时间来获取响应结果，这样不但造成了用户体验差，而且会经常出现请求执行失败的问题。</p><p>2.在解释异步调用之前，我们先来看同步调用的定义；</p><ol><li>同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。</li><li>异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。</li></ol><h1 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h1><p>1.在某个调用中，需要顺序调用 A, B, C三个过程方法；如他们都是同步调用，则需要将他们都顺序执行完毕之后，才算作过程执行完毕； 如B为一个异步的调用方法，则在执行完A之后，调用B，并不等待B完成，而是执行开始调用C，待C执行完毕之后，就意味着这个过程执行完毕了。</p><p>2.在生成订单的时候给用户发送短信，生成订单的结果不应该被发送短信的成功与否所左右，也就是说生成订单这个主操作是不依赖于发送短信这个操作，所以我们就可以把发送短信这个操作置为异步操作。</p><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p>@Async是spring为了方便开发人员进行异步调用的出现的，在方法上加入这个注解，spring会从线程池中获取一个新的线程来执行方法，实现异步调用</p><p>@EnableAsync表示开启对异步任务的支持，可以放在springboot的启动类上，也可以放在自定义线程池的配置类上，具体看下文</p><h1 id="二-最简单的使用"><a href="#二-最简单的使用" class="headerlink" title="二.最简单的使用"></a>二.最简单的使用</h1><p>在springboot项目中，直接在启动类上加上@EnableAsync，然后在service层的方法上对于需要异步调用的方法加上@Async，</p><p>那么当controller层调用这个方法的时候，就会在主线程外自动新建线程执行该方法。</p><p>1.springboot启动类开启异步支持<br><img src="/img/async-1.png" alt="图片"></p><p>2.service层的方法加@Async，如果在类上加该注解表示整个类的方法都异步执行，建议加到具体的某个方法上<br><img src="/img/async-2.png" alt="图片"></p><p>3.controller层调用service层的异步方法，这里用主线程在异步方法前后执行了2次打印输出<br><img src="/img/async-3.png" alt="图片"></p><p>4.调用的结果</p><p>首先看看没有异步执行，正常的顺序执行的结果</p><p>可以看到，按顺序执行，全部是main线程http-nio-8181-exec-124执行，并且service方法的执行结果在中间，如下所示<br><img src="/img/async-4.png" alt="图片"></p><p>由于我们的方法使用了@Async注解，所以主线程http-nio-8181-exec-124不等异步方法完成，先结束了，异步线程task-1继续执行.<br><img src="/img/async-5.png" alt="图片"></p><p><strong>tips：没有自定义线程池@Async默认的线程池是SimpleAsyncTaskExecutor</strong></p><h1 id="三-自定义线程池来使用-Async"><a href="#三-自定义线程池来使用-Async" class="headerlink" title="三.自定义线程池来使用@Async"></a>三.自定义线程池来使用@Async</h1><p>1.新建一个线程池配置类，@EnableAsync在配置类上加，不用在启动类上加也行，可以配置不同的线程池，用bean的name做区分<br><img src="/img/async-6.png" alt="图片"></p><p>2.@Async的使用一样是在service层的方法上加，如果配置了多个线程池，可以用@Async(“name”)，那么表示线程池的@Bean的name，来指定用哪个线程池处理.</p><p>假如只配置了一个线程池，直接用@Async就会用自定义的线程池执行.</p><p>假如配置了多个线程池，用@Async没指定用哪个线程池，会用默认的SimpleAsyncTaskExecutor来处理.<br><img src="/img/async-7.png" alt="图片"></p><p>假如配置了多个线程池，用@Async(“name”)，会用指定的线程池处理</p><p>比如service层方法上指定pool1线程池<br><img src="/img/async-8.png" alt="图片"></p><p>执行结果，异步线程名是pool配置的fzhThread<br><img src="/img/async-9.png" alt="图片"></p><h1 id="四-注解没生效的原因"><a href="#四-注解没生效的原因" class="headerlink" title="四.注解没生效的原因"></a>四.注解没生效的原因</h1><p>1.异步方法使用static修饰</p><p>2.异步方法类没有使用@Service注解（或其他注解）导致spring无法扫描到异步类</p><p>3.controller中需要使用@Autowired或@Resource等注解自动注入service类，不能自己手动new对象</p>]]></content>
      
      
      <categories>
          
          <category> 异步注解 </category>
          
          <category> Async </category>
          
          <category> EnableAsync和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步注解 </tag>
            
            <tag> EnableAsync </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务之@Scheduled注解</title>
      <link href="/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B9%8B@Scheduled%E6%B3%A8%E8%A7%A3/"/>
      <url>/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B9%8B@Scheduled%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、注解介绍"><a href="#一、注解介绍" class="headerlink" title="一、注解介绍"></a>一、注解介绍</h1><p> @Scheduled注解是Spring Boot提供的用于定时任务控制的注解，主要用于控制任务在某个指定时间执行，或者每隔一段时间执行。</p><h1 id="二、注解参数"><a href="#二、注解参数" class="headerlink" title="二、注解参数"></a>二、注解参数</h1><h2 id="2-1-参数简介"><a href="#2-1-参数简介" class="headerlink" title="2.1. 参数简介"></a>2.1. 参数简介</h2><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>cron</td><td>任务执行的cron表达式</td><td>见下文</td></tr><tr><td>zone</td><td>cron表达时解析使用的时区，默认为服务器的本地时区。使用java.util.TimeZone#getTimeZone(String)方法解析</td><td>GMT-8:00</td></tr><tr><td>fixedRate</td><td>固定速率。上一次任务执行开始到下一次执行开始的间隔时间固定，单位为ms。若在调度任务执行时,上一次任务还未执行完毕,会加入worker队列,等待上一次执行完成后，马上执行下一次任务</td><td>1000</td></tr><tr><td>fixedRateString</td><td>与fixedRate一致，只是间隔时间使用java.time.Duration#parse解析</td><td>1000或PT1S</td></tr><tr><td>fixedDelay</td><td>固定延迟。上一次任务执行结束到下一次执行开始的间隔时间固定，单位为ms。</td><td>1000</td></tr><tr><td>fixedDelayString</td><td>与fixedDelay一致，只是间隔时间使用java.time.Duration#parse解析</td><td>1000或PT1S</td></tr><tr><td>initialDelay</td><td>首次延迟多长时间后执行，单位ms。之后按照fixedRate、fixedRateString、fixedDelay、fixedDelayString指定的规则执行，需要指定其中一个规则。注意：不能和cron一起使用</td><td>1000</td></tr><tr><td>initialDelayString</td><td>与initialDelay 一致，只是间隔时间使用java.time.Duration#parse解析</td><td>1000或PT1S</td></tr></tbody></table><h2 id="2-2-主要参数说明"><a href="#2-2-主要参数说明" class="headerlink" title="2.2. 主要参数说明"></a>2.2. 主要参数说明</h2><p> 注意，@Scheduled需要配合@EnableScheduling使用。使用时，将@Scheduled注解放在待定时的方法名上方，将@EnableScheduling放在项目主启动类类名上方。@Scheduled主要有三种配置执行时间的方式：cron、fixedRate和fixedDelay。</p><h3 id="2-2-1-cron表达式"><a href="#2-2-1-cron表达式" class="headerlink" title="2.2.1. cron表达式"></a>2.2.1. cron表达式</h3><p>cron是@Scheduled的一个参数，是一个字符串，以空格隔开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cron表达式格式：</span><br><span class="line"> </span><br><span class="line">@Scheduled(cron = &quot;&#123;秒数&#125; &#123;分钟&#125; &#123;小时&#125; &#123;日期&#125; &#123;月份&#125; &#123;星期&#125;&quot;)</span><br><span class="line"> </span><br><span class="line">cron表达式示例：</span><br><span class="line"> </span><br><span class="line">@Scheduled(cron = &quot;0 00 07 * * *&quot;)</span><br></pre></td></tr></table></figure><p>cron表达式可分为6或7个占位符，但在spring自带的定时任务中，cron只支持6个参数（详情请参考2.3的源码），若使用7个参数就会报错，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(cron = &quot;0/3 * * * * ? 2022-2023&quot;)</span><br><span class="line">public void test()&#123;</span><br><span class="line"> </span><br><span class="line">    logger.info(&quot;输出测试！&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">org.springframework.beans.factory.BeanCreationException: </span><br><span class="line">Error creating bean with name &#x27;类名&#x27; defined in file </span><br><span class="line">[编译后class文件路径]: Initialization of bean failed; </span><br><span class="line"> </span><br><span class="line">nested exception is java.lang.IllegalStateException: </span><br><span class="line">Encountered invalid @Scheduled method &#x27;test&#x27;: Cron expression </span><br><span class="line">must consist of 6 fields (found 7 in &quot;0/3 * * * * ? 2022-2023&quot;)</span><br></pre></td></tr></table></figure><p>各参数介绍：</p><table><thead><tr><th>单位</th><th>允许值</th><th>允许通配符</th></tr></thead><tbody><tr><td>毫秒</td><td>0-59</td><td>,  -  *  &#x2F;</td></tr><tr><td>分钟</td><td>0-59</td><td>,  -  *  &#x2F;</td></tr><tr><td>小时</td><td>0-23</td><td>,  -  *  &#x2F;</td></tr><tr><td>日期</td><td>1-31</td><td>,  -  *  &#x2F;  ?  L  W</td></tr><tr><td>月份</td><td>1-12或JAN-DEC(大小写均可)</td><td>,  -  *  &#x2F;  ?</td></tr><tr><td>星期</td><td>1-7或SUN-SAT(大小写均可)</td><td>注：星期日为每周第一天，所以1-7表示周末到周六 ,  -  *  &#x2F;  ?  L  #</td></tr></tbody></table><p>cron表达式各占位符解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;秒数&#125;&#123;分钟&#125;&#123;小时&#125;&#123;日期&#125;&#123;星期&#125; ==&gt; 不允许为空值，若值不合法，调度器将抛出SchedulerException异常</span><br><span class="line"> </span><br><span class="line">“/”代表触发步进(step)，”/”前面的值代表初始值(&quot;&quot;等同&quot;0&quot;)，后面的值代表偏移量，比如</span><br><span class="line"> </span><br><span class="line">&quot;0/20&quot;或者&quot;/20&quot;代表从0秒钟开始，每隔20秒钟触发1次，即第0秒触发1次，第20秒触发1次，第40秒触发1次；</span><br><span class="line"> </span><br><span class="line">&quot;5/20&quot;代表第5秒触发1次，第25秒触发1次，第45秒触发1次；</span><br><span class="line"> </span><br><span class="line">&quot;10-45/20&quot;代表在[10,45]内步进20秒命中的时间点触发，即第10秒触发1次，第30秒触发1次</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="2-2-2-cron通配符"><a href="#2-2-2-cron通配符" class="headerlink" title="2.2.2. cron通配符"></a>2.2.2. cron通配符</h3><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>所有值,在秒字段上表示每秒执行,在月字段上表示每月执行</td></tr><tr><td>？</td><td>不指定值，不需要关心当前指定的字段的值，比如每天都执行但不需要关心周几就可以把周的字段设为?</td></tr><tr><td>-</td><td>区间或者范围,如秒的0-2 ,表示0秒、1秒、2秒都会触发</td></tr><tr><td>,</td><td>指定值，比如在0秒、20秒、25秒触发,可以把秒的字段设为0,20,25</td></tr><tr><td>&#x2F;</td><td>递增触发,比如秒的字段上设0&#x2F;3 ,表示从第0秒开始,每隔3秒触发</td></tr><tr><td>L</td><td>最后，只允许在日字段或周字段上,在日字段上使用L表示当月最后- -天,在周字段上使用3L表示该月最后一个周四</td></tr><tr><td>W</td><td>只允许用在日字段上,表示距离最近的该日的工作日,工作日指的是周一至周五</td></tr><tr><td>#</td><td>只允许在周字段上，表示每月的第几个周几，如2#3 , 每月的第3个周二</td></tr></tbody></table><h3 id="2-2-3-cron表达式示例"><a href="#2-2-3-cron表达式示例" class="headerlink" title="2.2.3. cron表达式示例"></a>2.2.3. cron表达式示例</h3><p>@Scheduled(cron &#x3D; “* * * * * <em>“)示例：</em>每秒执行</p><p>@Scheduled(cron &#x3D; “10-45&#x2F;20 * * * * *”)示例：-和&#x2F;占位符的组合使用</p><p>@Scheduled(cron &#x3D; “*&#x2F;5 * * * * <em>“)示例：</em>和&#x2F;的使用，程序启动后，每5秒执行一次</p><p>@Scheduled(cron &#x3D; “25&#x2F;5 * * * * *”)示例：与上述示例对比，从25秒起，每5秒执行一次</p><p>其他示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">“30 * * * * ?” 每半分钟触发任务 </span><br><span class="line"> </span><br><span class="line">“30 10 * * * ?” 每小时的10分30秒触发任务 </span><br><span class="line"> </span><br><span class="line">“30 10 1 * * ?” 每天1点10分30秒触发任务 </span><br><span class="line"> </span><br><span class="line">“30 10 1 20 * ?” 每月20号1点10分30秒触发任务 </span><br><span class="line"> </span><br><span class="line">“30 10 1 20 10 ? *” 每年10月20号1点10分30秒触发任务 </span><br><span class="line"> </span><br><span class="line">“30 10 1 20 10 ? 2011” 2011年10月20号1点10分30秒触发任务 </span><br><span class="line"> </span><br><span class="line">“30 10 1 ? 10 * 2011” 2011年10月每天1点10分30秒触发任务 </span><br><span class="line"> </span><br><span class="line">“30 10 1 ? 10 SUN 2011” 2011年10月每周日1点10分30秒触发任务 </span><br><span class="line"> </span><br><span class="line">“15,30,45 * * * * ?” 每15秒，30秒，45秒时触发任务 </span><br><span class="line"> </span><br><span class="line">“15-45 * * * * ?” 15到45秒内，每秒都触发任务 </span><br><span class="line"> </span><br><span class="line">“15/5 * * * * ?” 每分钟的每15秒开始触发，每隔5秒触发一次 </span><br><span class="line"> </span><br><span class="line">“15-30/5 * * * * ?” 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次 </span><br><span class="line"> </span><br><span class="line">“0 0/3 * * * ?” 每小时的第0分0秒开始，每三分钟触发一次 </span><br><span class="line"> </span><br><span class="line">“0 15 10 ? * MON-FRI” 星期一到星期五的10点15分0秒触发任务 </span><br><span class="line"> </span><br><span class="line">“0 15 10 L * ?” 每个月最后一天的10点15分0秒触发任务 </span><br><span class="line"> </span><br><span class="line">“0 15 10 LW * ?” 每个月最后一个工作日的10点15分0秒触发任务 </span><br><span class="line"> </span><br><span class="line">“0 15 10 ? * 5L” 每个月最后一个星期四的10点15分0秒触发任务 </span><br><span class="line"> </span><br><span class="line">“0 15 10 ? * 5#3” 每个月第三周的星期四的10点15分0秒触发任务</span><br></pre></td></tr></table></figure><h3 id="2-2-4-cron表达式参数数量解疑"><a href="#2-2-4-cron表达式参数数量解疑" class="headerlink" title="2.2.4. cron表达式参数数量解疑"></a>2.2.4. cron表达式参数数量解疑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cron表达式格式：在此，表达式以空格分为6或7个域</span><br><span class="line"> </span><br><span class="line">@Scheduled(cron = &quot;&#123;秒数&#125; &#123;分钟&#125; &#123;小时&#125; &#123;日期&#125; &#123;月份&#125; &#123;星期&#125; &#123;年份(可为空)&#125;&quot;)</span><br><span class="line"> </span><br><span class="line">&#123;年份&#125; ==&gt; 允许值范围: 1970~2099 ,允许为空，若值不合法，调度器将抛出SchedulerException异常</span><br><span class="line"> </span><br><span class="line">注意：除了&#123;日期&#125;和&#123;星期&#125;可以使用”?”来实现互斥，表达无意义的信息之外，其他占位符都要具有具体的时间含义，且依赖关系为：年-&gt;月-&gt;日期(星期)-&gt;小时-&gt;分钟-&gt;秒数</span><br></pre></td></tr></table></figure><h2 id="2-3-源码"><a href="#2-3-源码" class="headerlink" title="2.3.源码"></a>2.3.源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(Schedules.class)</span><br><span class="line">public @interface Scheduled &#123;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * A special cron expression value that indicates a disabled trigger: &#123;@value&#125;.</span><br><span class="line"> * 一个特殊的cron表达式值，指示禁用的触发器：｛@value｝。</span><br><span class="line"> * &lt;p&gt;This is primarily meant for use with &lt;code&gt;$&#123;...&#125;&lt;/code&gt; placeholders,</span><br><span class="line"> * allowing for external disabling of corresponding scheduled methods.</span><br><span class="line"> * @since 5.1</span><br><span class="line"> * @see ScheduledTaskRegistrar#CRON_DISABLED</span><br><span class="line"> */</span><br><span class="line">String CRON_DISABLED = ScheduledTaskRegistrar.CRON_DISABLED;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * A cron-like expression, extending the usual UN*X definition to include triggers</span><br><span class="line"> * on the second, minute, hour, day of month, month, and day of week.</span><br><span class="line"> * 类似cron的表达式，将通常的UN*X定义扩展为包括触发器在秒、分钟、小时、天、月份和星期几。</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;For example, &#123;@code &quot;0 * * * * MON-FRI&quot;&#125; means once per minute on weekdays</span><br><span class="line"> * (at the top of the minute - the 0th second).</span><br><span class="line"> * &lt;p&gt;The fields read from left to right are interpreted as follows.</span><br><span class="line"> * 从左到右读取的字段解释如下。</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;second&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;minute&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;hour&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;day of month&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;month&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;day of week&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> * &lt;p&gt;The special value &#123;@link #CRON_DISABLED &quot;-&quot;&#125; indicates a disabled cron</span><br><span class="line"> * trigger, primarily meant for externally specified values resolved by a</span><br><span class="line"> * &lt;code&gt;$&#123;...&#125;&lt;/code&gt; placeholder.</span><br><span class="line"> * @return an expression that can be parsed to a cron schedule</span><br><span class="line"> * @see org.springframework.scheduling.support.CronExpression#parse(String)</span><br><span class="line"> */</span><br><span class="line">String cron() default &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * A time zone for which the cron expression will be resolved. </span><br><span class="line"> * 将解析cron表达式的时区。</span><br><span class="line"> * By default, this attribute is the empty String (i.e. the server&#x27;s local time zone will be used).</span><br><span class="line"> * 默认情况下，此属性为空字符串（即将使用服务器的本地时区）。</span><br><span class="line"> * @return a zone id accepted by &#123;@link java.util.TimeZone#getTimeZone(String)&#125;,</span><br><span class="line"> * or an empty String to indicate the server&#x27;s default time zone</span><br><span class="line"> * @since 4.0</span><br><span class="line"> * @see org.springframework.scheduling.support.CronTrigger#CronTrigger(String, java.util.TimeZone)</span><br><span class="line"> * @see java.util.TimeZone</span><br><span class="line"> */</span><br><span class="line">String zone() default &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Execute the annotated method with a fixed period in milliseconds between the</span><br><span class="line"> * end of the last invocation and the start of the next.</span><br><span class="line"> * 在上一次调用结束和下一次调用开始之间以毫秒为单位的固定周期内执行带注释的方法。</span><br><span class="line"> * </span><br><span class="line"> * @return the delay in milliseconds</span><br><span class="line"> */</span><br><span class="line">long fixedDelay() default -1;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Execute the annotated method with a fixed period in milliseconds between the</span><br><span class="line"> * end of the last invocation and the start of the next.</span><br><span class="line"> * 在上一次调用结束和下一次调用开始之间以毫秒为单位的固定周期内执行带注释的方法。</span><br><span class="line"> * </span><br><span class="line"> * @return the delay in milliseconds as a String value, e.g. a placeholder</span><br><span class="line"> * or a &#123;@link java.time.Duration#parse java.time.Duration&#125; compliant value</span><br><span class="line"> * @since 3.2.2</span><br><span class="line"> */</span><br><span class="line">String fixedDelayString() default &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Execute the annotated method with a fixed period in milliseconds between</span><br><span class="line"> * invocations.</span><br><span class="line"> * 在两次调用之间以毫秒为单位执行带注释的方法。</span><br><span class="line"> *</span><br><span class="line"> * @return the period in milliseconds</span><br><span class="line"> */</span><br><span class="line">long fixedRate() default -1;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Execute the annotated method with a fixed period in milliseconds between</span><br><span class="line"> * invocations.</span><br><span class="line"> * 在两次调用之间以毫秒为单位执行带注释的方法。</span><br><span class="line"> *</span><br><span class="line"> * @return the period in milliseconds as a String value, e.g. a placeholder</span><br><span class="line"> * or a &#123;@link java.time.Duration#parse java.time.Duration&#125; compliant value</span><br><span class="line"> * @since 3.2.2</span><br><span class="line"> */</span><br><span class="line">String fixedRateString() default &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Number of milliseconds to delay before the first execution of a</span><br><span class="line"> * &#123;@link #fixedRate&#125; or &#123;@link #fixedDelay&#125; task.</span><br><span class="line"> * 首次执行｛@link#fixedRate｝或｛@link#fixedDelay｝任务之前要延迟的毫秒数。</span><br><span class="line"> *</span><br><span class="line"> * @return the initial delay in milliseconds</span><br><span class="line"> * @since 3.2</span><br><span class="line"> */</span><br><span class="line">long initialDelay() default -1;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Number of milliseconds to delay before the first execution of a</span><br><span class="line"> * &#123;@link #fixedRate&#125; or &#123;@link #fixedDelay&#125; task.</span><br><span class="line"> * 首次执行｛@link#fixedRate｝或｛@link#fixedDelay｝任务之前要延迟的毫秒数。</span><br><span class="line"> *</span><br><span class="line"> * @return the initial delay in milliseconds as a String value, e.g. a placeholder</span><br><span class="line"> * or a &#123;@link java.time.Duration#parse java.time.Duration&#125; compliant value</span><br><span class="line"> * @since 3.2.2</span><br><span class="line"> */</span><br><span class="line">String initialDelayString() default &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、cron生成"><a href="#三、cron生成" class="headerlink" title="三、cron生成"></a>三、cron生成</h1><p>在<a href="https://cron.qqe2.com/">在线Cron表达式生成器</a>可以生成Cron表达式，同时，也可以反解析。还有一些程序员常用的工具。</p>]]></content>
      
      
      <categories>
          
          <category> Scheduled注解 </category>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
            <tag> java </tag>
            
            <tag> Scheduled注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/Algorithm/"/>
      <url>/Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="一、动态规划"><a href="#一、动态规划" class="headerlink" title="一、动态规划"></a>一、动态规划</h1><p>动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过<strong>将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解</strong>。&#x3D;&#x3D;动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率&#x3D;&#x3D;。</p><p>动态规划适用于满足以下两个条件的问题：</p><ol><li><p>重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。</p></li><li><p>最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。</p></li></ol><p>动态规划通常有两种常见的方法：</p><ol><li><p>自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。</p></li><li><p>自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。</p></li></ol><p>动态规划广泛应用于许多领域，例如：</p><ul><li>背包问题（Knapsack Problem）</li><li>最短路径问题（Shortest Path Problem）</li><li>最长公共子序列问题（Longest Common Subsequence Problem）</li><li>斐波那契数列问题（Fibonacci Sequence Problem）</li><li>编辑距离问题（Edit Distance Problem）</li><li>最大子数组和问题（Maximum Subarray Sum Problem）</li><li>…等等</li></ul><p>总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。</p><p><strong>大致步骤：</strong></p><ol><li><p><strong>定义子问题：</strong> 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。</p></li><li><p><strong>找出状态转移方程：</strong> 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。</p></li><li><p><strong>初始化：</strong> 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。</p></li><li><p><strong>自底向上求解（或者记忆化递归）：</strong> 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。</p></li><li><p><strong>存储中间结果：</strong> 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。</p></li><li><p><strong>得到最终解：</strong> 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。</p></li><li><p><strong>可选的优化：</strong> 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。</p></li></ol><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p><strong>题目：</strong><br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：<br>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p><p>示例 2：<br>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4</p><p>示例 3：<br>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p><p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p><strong>注意</strong>「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的</p><p><strong>思想解释：</strong></p><ol><li>我们使用一个数组 <code>dp</code> 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。</li><li>我们从数组的第二个元素开始遍历，对于每个元素 <code>nums[i]</code>，我们再遍历它之前的所有元素 <code>nums[j]</code>（<code>j &lt; i</code>）。如果 <code>nums[i]</code> 大于 <code>nums[j]</code>，说明可以将 <code>nums[i]</code> 加入以 <code>nums[j]</code> 结尾的子序列，从而构成一个更长的递增子序列。我们更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code>，表示以 <code>nums[i]</code> 结尾的最长递增子序列长度。</li><li>在内层循环中，我们不断更新 <code>dp[i]</code>，找到以当前元素 <code>nums[i]</code> 结尾的最长递增子序列长度。</li><li>在整个过程中，我们维护一个全局变量 <code>maxLen</code>，记录最长递增子序列的长度。</li><li>最终，遍历完整个数组后，<code>maxLen</code> 就是最长递增子序列的长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestIncreasingSubsequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]; <span class="comment">// dp[i] 表示以 nums[i] 结尾的最长递增子序列长度</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化，单个元素也构成递增子序列</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 最长递增子序列长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>; <span class="comment">// 默认以当前元素为结尾的子序列长度为 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>); <span class="comment">// 更新最长递增子序列长度</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen, dp[i]); <span class="comment">// 更新全局最长长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lisLength</span> <span class="operator">=</span> lengthOfLIS(nums);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length of Longest Increasing Subsequence: &quot;</span> + lisLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><strong>题目：</strong><br>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><p>示例 1:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p>示例 2:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p>示例 3:<br>输入:<br>s &#x3D; “ab”<br>p &#x3D; “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p><p>示例 4:<br>输入:<br>s &#x3D; “aab”<br>p &#x3D; “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p><p>示例 5:<br>输入:<br>s &#x3D; “mississippi”<br>p &#x3D; “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。</p><p><strong>解题思路如下：</strong></p><ol><li>我们可以使用动态规划来解决正则表达式匹配问题。</li><li>定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。</li><li>初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。</li><li>遍历字符串和正则表达式的每个字符，逐步填充dp数组。</li><li>如果s[i]和p[j]相等，或者p[j]为’.’，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。</li><li>如果p[j]为’*’，则需要考虑两种情况：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-  &#x27;*&#x27;表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。</span><br><span class="line">-  &#x27;*&#x27;表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为&#x27;.&#x27;。</span><br></pre></td></tr></table></figure><ol start="7"><li>其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。</li><li>最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularExpressionMatching</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i][j]表示s的前i个字符和p的前j个字符是否匹配</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 空字符串和空正则表达式匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理空正则表达式可以匹配的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填充dp表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">sc</span> <span class="operator">=</span> s.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="type">char</span> <span class="variable">pc</span> <span class="operator">=</span> p.charAt(j - <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (sc == pc || pc == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">prevPc</span> <span class="operator">=</span> p.charAt(j - <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span> (prevPc == sc || prevPc == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 匹配0次、1次或多次</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - <span class="number">2</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 匹配0次</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;mississippi&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;mis*is*p*.&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> isMatch(s, p);</span><br><span class="line">        System.out.println(<span class="string">&quot;Is match: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释解释：</p><ol><li><code>dp[i][j]</code>表示s的前i个字符和p的前j个字符是否匹配。</li><li>初始化：空字符串和空正则表达式匹配，<code>dp[0][0] = true</code>。</li><li>处理空正则表达式可以匹配的情况：如果p的某个字符是’*’，那么它可以匹配0次，将<code>dp[0][j]</code>设置为<code>dp[0][j-2]</code>。</li><li>填充dp表格：根据字符匹配和’*’的特性，更新<code>dp[i][j]</code>的值。</li><li>最终结：<code>dp[m][n]</code>表示s的全部字符和p的全部字符是否匹配。</li></ol><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>回文串是指正着读和倒着读都一样的字符串。例如，”aba”、”abba”和”level”都是回文串。</p><p><strong>题目：</strong><br>给你一个字符串 s，找到 s 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>示例 1：<br>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p>示例 2：<br>输入：s &#x3D; “cbbd”<br>输出：”bb”</p><p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母组成</p><p><strong>解题思路：</strong></p><ol><li>我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。</li><li>初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] &#x3D; true。</li><li>遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。</li><li>对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) &amp;&amp; dp[i+1][j-1]。</li><li>如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。</li><li>最终得到的最长回文子串就是最长的回文串。</li></ol><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestPalindromeSubstring</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n]; <span class="comment">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录最长回文子串的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录最长回文子串的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有单个字符都是回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查长度为2的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                maxLength = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查长度大于2的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">3</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len - <span class="number">1</span>; <span class="comment">// 子串的结束位置</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                    maxLength = len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;babad&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">longestPalindrome</span> <span class="operator">=</span> longestPalindrome(input);</span><br><span class="line">        System.out.println(<span class="string">&quot;Longest Palindrome Substring: &quot;</span> + longestPalindrome);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释解释：</p><ol><li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li><li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>。</li><li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>。</li><li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。</li><li>最终结果：根据<code>dp</code>数组的信息，找到最长回文子串的起始位置和长度，然后通过<code>substring</code>方法获取最长回文子串。<br>注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。</li></ol><h2 id="回文子串个数"><a href="#回文子串个数" class="headerlink" title="回文子串个数"></a>回文子串个数</h2><p><strong>题目：</strong><br>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：<br>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p><p>示例 2：<br>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p><p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由小写英文字母组成</p><p><strong>解法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountPalindromicSubstrings</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录回文子串的个数</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n]; <span class="comment">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有单个字符都是回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查长度为2的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查长度大于2的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">3</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len - <span class="number">1</span>; <span class="comment">// 子串的结束位置</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">palindromeCount</span> <span class="operator">=</span> countSubstrings(input);</span><br><span class="line">        System.out.println(<span class="string">&quot;Palindrome Substrings Count: &quot;</span> + palindromeCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释解释：</p><ol><li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li><li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>，并且<code>count</code>加1。</li><li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>，并且<code>count</code>加1。</li><li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则<code>dp[i][j]</code>为true，同时<code>count</code>加1。</li><li>最终结果：返回<code>count</code>，即回文子串的个数。</li></ol><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。</p><p><strong>解题思路：</strong></p><ol><li>我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示在前i个物品中选择总重量不超过j的情况下的最大价值。</li><li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。</li><li>遍历物品和背包承载重量，对于每个物品和背包承载重量：</li></ol><ul><li>如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以<code>dp[i][j]</code>的最大价值和<code>dp[i-1][j]</code>一样。</li><li>如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为<code>j - weights[i]</code>，所以最大价值为<code>values[i] + dp[i-1][j-weights[i]]</code>；如果不放入物品i，则最大价值为<code>dp[i-1][j]</code>。我们选择两者中较大的值作为<code>dp[i][j]</code>的最大价值。其中 <code>weight[i]</code> 为物品 i 的重量，<code>value[i]</code> 为物品 i 的价值。</li></ul><ol start="4"><li>最后<code>dp[n][W]</code>即为问题的解，其中n表示物品的个数，W表示背包的承载重量。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class KnapsackProblem &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param weights    物品的重量数组</span><br><span class="line">     * @param values     价值数组</span><br><span class="line">     * @param capacity   背包容量</span><br><span class="line">     * @return 最大价值</span><br><span class="line">     */</span><br><span class="line">    public static int knapsack(int[] weights, int[] values, int capacity) &#123;</span><br><span class="line"></span><br><span class="line">        int n = weights.length;</span><br><span class="line"></span><br><span class="line">        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值</span><br><span class="line">        int[][] dp = new int[n + 1][capacity + 1];</span><br><span class="line"></span><br><span class="line">        // 填充 dp 数组，进行状态转移</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= capacity; j++) &#123;</span><br><span class="line">                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值</span><br><span class="line">                if (weights[i - 1] &gt; j) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值</span><br><span class="line">        return dp[n][capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] weights = &#123;2, 3, 4, 5&#125;;</span><br><span class="line">        int[] values = &#123;3, 4, 5, 6&#125;;</span><br><span class="line">        int capacity = 5;</span><br><span class="line">        int result = knapsack(weights, values, capacity);</span><br><span class="line">        System.out.println(&quot;Maximum value: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 输出结果</span><br><span class="line">Maximum value: 7</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列（Longest-Common-Subsequence）问题"><a href="#最长公共子序列（Longest-Common-Subsequence）问题" class="headerlink" title="最长公共子序列（Longest Common Subsequence）问题"></a>最长公共子序列（Longest Common Subsequence）问题</h2><p>最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。</p><p>给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。</p><p><strong>解题思路：</strong></p><ol><li>我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。</li><li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。</li><li>遍历两个序列的元素，对于每个元素<code>A[i]</code>和<code>B[j]</code>：</li></ol><ul><li>如果<code>A[i]</code>和<code>B[j]</code>相等，说明它们可以作为最长公共子序列的一部分，因此<code>dp[i][j]</code>的值应该是<code>dp[i-1][j-1] + 1</code>，即在之前的最长公共子序列长度上加1。</li><li>如果<code>A[i]</code>和<code>B[j]</code>不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>中的较大值作为<code>dp[i][j]</code>的值。</li></ul><ol start="4"><li>最后，<code>dp[n][m]</code>即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class LongestCommonSubsequence &#123;</span><br><span class="line"></span><br><span class="line">    public static int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">        int m = text1.length();</span><br><span class="line">        int n = text2.length();</span><br><span class="line"></span><br><span class="line">        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class="line">        int[][] dp = new int[m + 1][n + 1];</span><br><span class="line"></span><br><span class="line">        // 填充 dp 数组，进行状态转移</span><br><span class="line">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一</span><br><span class="line">                if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回 text1 和 text2 的最长公共子序列长度</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String text1 = &quot;abcde&quot;;</span><br><span class="line">        String text2 = &quot;ace&quot;;</span><br><span class="line">        int result = longestCommonSubsequence(text1, text2);</span><br><span class="line">        System.out.println(&quot;Longest Common Subsequence: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Longest Common Subsequence: 3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。"><a href="#打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。" class="headerlink" title="打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。"></a>打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。</h2><p><strong>题目：</strong></p><p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p><p>示例 2：</p><p>输入：nums &#x3D; [2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li></ul><p><strong>解题思路：</strong></p><ol><li>我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。</li><li>初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。</li><li>遍历数组，对于每个房屋i，考虑两种情况：</li></ol><ul><li>偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。</li><li>不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。</li><li>取两种情况中的较大值作为dp[i]的值。</li></ul><ol start="4"><li>最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class HouseRobberI &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param nums 一个代表每个房屋存放金额的非负整数数组</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int rob(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        int n = nums.length;</span><br><span class="line"></span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额</span><br><span class="line">        int[] dp = new int[n];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = Math.max(nums[0], nums[1]);</span><br><span class="line"></span><br><span class="line">        for (int i = 2; i &lt; n; i++) &#123;</span><br><span class="line">            // 在当前房屋偷窃或不偷窃之间选择最大值</span><br><span class="line">            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回最后一个房屋偷窃或不偷窃的最大金额</span><br><span class="line">        return dp[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;2, 7, 9, 3, 1&#125;;</span><br><span class="line">        int result = rob(nums);</span><br><span class="line">        System.out.println(&quot;Maximum amount: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Maximum amount: 12</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h1><p>回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。</p><p>回溯算法的基本步骤如下：</p><ul><li>确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。</li><li>递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。</li><li>剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。</li></ul><p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p><p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p><p>一些常见的回溯算法问题包括：</p><ul><li>全排列（Permutations）</li><li>组合求和（Combination Sum）</li><li>子集（Subsets）</li><li>N皇后问题（N-Queens）</li><li>单词搜索（Word Search）</li><li>正则表达式匹配（Regular Expression Matching）等。</li></ul><p>回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。</p><p><strong>回溯算法框架：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Value&gt; result;</span><br><span class="line">void backtrack(路径， 选择列表) &#123;</span><br><span class="line">    if (满足结束条件) &#123;</span><br><span class="line">        result.add(路径);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (选择 ： 选择列表) &#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtrack(路径， 选择列表);</span><br><span class="line">        撤销选择;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。</p><p><strong>解题思路如下：</strong></p><ol><li>首先，我们可以使用递归来实现回溯算法。</li><li>使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。</li><li>递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。</li><li>在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。</li><li>在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。</li></ol><p><strong>题目：</strong></p><p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p><p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><p>示例 2：<br>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]</p><p>示例 3：<br>输入：nums &#x3D; [1]<br>输出：[[1]]</p><p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 6<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有整数 互不相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class PermutationsBacktracking &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;1, 2, 3&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permutations = permute(nums);</span><br><span class="line">        for (List&lt;Integer&gt; permutation : permutations) &#123;</span><br><span class="line">            System.out.println(permutation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化了一个空的结果列表</span><br><span class="line">    public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        // 全排列</span><br><span class="line">        backtrack(nums, new ArrayList&lt;&gt;(), result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 回溯函数，用于生成全排列</span><br><span class="line">     * @param nums      数组 【1，2，3】</span><br><span class="line">     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素</span><br><span class="line">     * @param result    存储全排列结果</span><br><span class="line">     */</span><br><span class="line">    private static void backtrack(int[] nums, List&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">        // 到达叶子节点，将路径装入结果列表</span><br><span class="line">        if (track.size() == nums.length) &#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 尝试每个未使用的元素</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (track.contains(num)) &#123;</span><br><span class="line">                // 如果当前数字已经在排列中，跳过</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            track.add(num);</span><br><span class="line">            // 递归调用</span><br><span class="line">            backtrack(nums, track, result);</span><br><span class="line">            // 回溯，移除最后一个元素</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]</span><br><span class="line">[1, 3, 2]</span><br><span class="line">[2, 1, 3]</span><br><span class="line">[2, 3, 1]</span><br><span class="line">[3, 1, 2]</span><br><span class="line">[3, 2, 1]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1 id="三、贪心算法"><a href="#三、贪心算法" class="headerlink" title="三、贪心算法"></a>三、贪心算法</h1><p><strong>核心思想：</strong><br>贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。</p><p>贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。</p><p><strong>贪心算法的一般步骤如下</strong>：</p><ol><li>定义问题的解空间，即所有可能的解组成的集合。</li><li>制定选择策略，即在每一步都选择一个局部最优解。</li><li>确定是否满足问题的约束条件，即该解是否可行。</li><li>判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。</li></ol><p>需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。</p><p><strong>常见算法题：</strong></p><ol><li>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</li><li>区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。</li><li>分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。</li><li>买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。</li><li>跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。</li><li>柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。</li><li>汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。</li><li>分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。</li><li>非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。</li><li>跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。</li></ol><h2 id="零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。"><a href="#零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。" class="headerlink" title="零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。"></a>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</h2><p>在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。</p><p>贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。</p><p><strong>解：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class CoinChangeGreedy &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] coins = &#123;1, 2, 5&#125;; // 零钱的面额</span><br><span class="line">        int amount = 11; // 要兑换的金额</span><br><span class="line">        int numCoins = coinChange(coins, amount);</span><br><span class="line">        System.out.println(&quot;最少需要的硬币数：&quot; + numCoins);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param coins    硬币面额</span><br><span class="line">     * @param amount   要兑换的金额</span><br><span class="line">     * @return 最少使用硬币数目</span><br><span class="line">     */</span><br><span class="line">    public static int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">        // 面额按从小到大排序</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line"></span><br><span class="line">        // 记录硬币数量</span><br><span class="line">        int count = 0;</span><br><span class="line">        // 从最大面额的硬币开始尝试</span><br><span class="line">        int index = coins.length - 1;</span><br><span class="line"></span><br><span class="line">        while (amount &gt; 0 &amp;&amp; index &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">            if (coins[index] &lt;= amount) &#123;</span><br><span class="line">                // 尝试使用当前面额的硬币数量</span><br><span class="line">                int numCoins = amount / coins[index];</span><br><span class="line">                count += numCoins;</span><br><span class="line">                amount -= numCoins * coins[index];</span><br><span class="line">            &#125;</span><br><span class="line">            // 尝试下一个面额的硬币</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换</span><br><span class="line">        return amount == 0 ? count : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最少需要的硬币数：3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。&#x3D;&#x3D;注意&#x3D;&#x3D;，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。</p><p>在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explain详解与索引最佳实践</title>
      <link href="/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>1. Explain使用与详解</strong><br><strong>1. Explain介绍</strong><br>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈<br>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会<br>返回执行计划的信息，而不是执行这条SQL。<br><strong>注意</strong>： 如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。</p><p><strong>Explain分析示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">示例表：</span><br><span class="line">2 DROP TABLE IF EXISTS `actor`;</span><br><span class="line">3 CREATE TABLE `actor` (</span><br><span class="line">4 `id` int(11) NOT NULL,</span><br><span class="line">5 `name` varchar(45) DEFAULT NULL,</span><br><span class="line">6 `update_time` datetime DEFAULT NULL,</span><br><span class="line">7 PRIMARY KEY (`id`)</span><br><span class="line">8 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">9</span><br><span class="line">10 INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (1,&#x27;a&#x27;,&#x27;2017‐12‐22</span><br><span class="line">15:27:18&#x27;), (2,&#x27;b&#x27;,&#x27;2017‐12‐22 15:27:18&#x27;), (3,&#x27;c&#x27;,&#x27;2017‐12‐22 15:27:18&#x27;);</span><br><span class="line">11</span><br><span class="line">12 DROP TABLE IF EXISTS `film`;</span><br><span class="line">13 CREATE TABLE `film` (</span><br><span class="line">14 `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">15 `name` varchar(10) DEFAULT NULL,</span><br><span class="line">16 PRIMARY KEY (`id`),</span><br><span class="line">17 KEY `idx_name` (`name`)</span><br><span class="line">18 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">19</span><br><span class="line">20 INSERT INTO `film` (`id`, `name`) VALUES (3,&#x27;film0&#x27;),(1,&#x27;film1&#x27;),(2,&#x27;film2&#x27;);</span><br><span class="line">21</span><br><span class="line">22 DROP TABLE IF EXISTS `film_actor`;</span><br><span class="line">23 CREATE TABLE `film_actor` (</span><br><span class="line">24 `id` int(11) NOT NULL,</span><br><span class="line">25 `film_id` int(11) NOT NULL,</span><br><span class="line">26 `actor_id` int(11) NOT NULL,</span><br><span class="line">27 `remark` varchar(255) DEFAULT NULL,</span><br><span class="line">28 PRIMARY KEY (`id`),</span><br><span class="line">29 KEY `idx_film_actor_id` (`film_id`,`actor_id`)</span><br><span class="line">30 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">31</span><br><span class="line">32 INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (1,1,1),(2,1,2),(3,2,1);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from actor;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain1.png" alt="图片"><br>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。</p><p><strong>explain 两个变种</strong><br><strong>1）explain extended</strong>：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered&#x2F;100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain extended select * from film where id = 1;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain2.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; show warnings;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain3.png" alt="图片"></p><p><strong>2）explain partitions</strong>：相比 explain 多了个 partitions字段，如果查询是基于分区表<br>的话，会显示查询将访问的分区。</p><h3 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a><strong>explain中的列</strong></h3><p>接下来我们将展示 explain 中每个列的信息。</p><p><strong>1. id列</strong><br>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。<br>举例： id有1,2,3，则id为3的执行优先级最高。</p><p><strong>2. select_type列</strong><br>select_type 表示对应行是简单还是复杂的查询。</p><p>1）simple：简单查询。查询不包含子查询和union。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film where id = 2;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain4.png" alt="图片"><br>2）primary：复杂查询中最外层的 select。<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）。<br>4）derived：衍生查询。包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）。<br>用这个例子来了解 primary、subquery 和 derived 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合</span><br><span class="line">并优化</span><br><span class="line">2 mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where</span><br><span class="line">id = 1) der;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain5.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置</span><br></pre></td></tr></table></figure><p>5）union：在 union 中的第二个和随后的 select</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select 1 union all select 1;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain6.png" alt="图片"></p><p><strong>3. table列</strong><br>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p><p><strong>4. type列</strong><br>这一列表示<strong>关联类型或访问类型</strong>，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL(全局)</strong><br>一般来说，<strong>得保证查询达到range级别，最好达到ref</strong>。</p><p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain7.png" alt="图片"></p><p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。const通俗点就是说和查询一个常量一样很快。用于primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<strong>system是const的特例</strong>，表里只有一条元组匹配时为system。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain8.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; show warnings;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain9.png" alt="图片"></p><p><strong>eq_ref</strong>：primary key(主键) 或 unique key(唯一键) 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain10.png" alt="图片"></p><p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p><ol><li>简单 select 查询，name是普通索引（非唯一索引）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film where name = &#x27;film1&#x27;;</span><br></pre></td></tr></table></figure><img src="/img/mysql_explain11.png" alt="图片"></li></ol><p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain12.png" alt="图片"></p><p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor where id &gt; 1;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain13.png" alt="图片"></p><p><strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain14.png" alt="图片"></p><p><strong>ALL</strong>：即全表扫描，扫描你的聚簇索引的所有叶子节点。<strong>通常情况下这需要增加索引来进行优化了</strong>。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain15.png" alt="图片"></p><p><strong>5. possible_keys列</strong><br>这一列显示查询<strong>可能使用</strong>哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引<br>对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提<br>高查询性能，然后用 explain 查看效果。</p><p><strong>6. key列</strong><br>这一列显示mysql<strong>实际采用</strong>哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，<br>在查询中使用 force index、ignore index。</p><p><strong>7. key_len列</strong><br>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id = 2;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain16.png" alt="图片"><br><strong>key_len计算规则如下：</strong></p><ul><li><p>字符串，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数</strong>，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节。</p><ul><li>char(n)：如果存汉字长度就是 3n 字节。</li><li>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为<br>varchar是变长字符串。</li></ul></li><li><h2 id="数值类型-tinyint：1字节-smallint：2字节-int：4字节-bigint：8字节"><a href="#数值类型-tinyint：1字节-smallint：2字节-int：4字节-bigint：8字节" class="headerlink" title="数值类型-  tinyint：1字节-  smallint：2字节-  int：4字节-  bigint：8字节"></a>数值类型<br>-  tinyint：1字节<br>-  smallint：2字节<br>-  int：4字节<br>-  bigint：8字节</h2></li><li><p>时间类型</p><ul><li>date：3字节</li><li>timestamp：4字节</li><li>datetime：8字节</li></ul></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p><p><strong>8. ref列</strong><br>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p><p><strong>9. rows列</strong><br>这一列是mysql估计要读取并检测的行数，<strong>注意</strong>这个不是结果集里的行数。</p><p><strong>10. Extra列</strong><br>这一列展示的是额外信息。常见的重要值如下：<br><strong>1）Using index</strong>：使用覆盖索引。<br><strong>覆盖索引定义</strong>：覆盖索引并不是一种索引，它是一种查询的方式，表示所查询的字段在索引树里都包含了。mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。如下：film_id在索引树里包含了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select film_id from film_actor where film_id = 1;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain17.png" alt="图片"></p><p><strong>2）Using where</strong>：使用 where 语句来处理结果，并且查询的列未被索引覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id &gt; 1;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain18.png" alt="图片"></p><p><strong>3）Using index condition</strong>：查询的列不完全被索引覆盖，where条件中是一个前导列的范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id &gt; 1;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain19.png" alt="图片"></p><p><strong>4）Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><ol><li><p>actor.name没有索引，此时创建了张临时表来distinct。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from actor;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain20.png" alt="图片"></p></li><li><p>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from film;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain21.png" alt="图片"></p></li></ol><p><strong>5）Using filesort</strong>：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><ol><li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor order by name;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain22.png" alt="图片"></p></li><li><p>film.name建立了idx_name索引,此时查询时extra是using index。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film order by name;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain23.png" alt="图片"></p></li></ol><p><strong>6）Select tables optimized away</strong>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain24.png" alt="图片"></p><h3 id="索引最佳实践"><a href="#索引最佳实践" class="headerlink" title="索引最佳实践"></a><strong>索引最佳实践</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例表：</span><br><span class="line">2 CREATE TABLE `employees` (</span><br><span class="line">3 `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">4 `name` varchar(24) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">5 `age` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,</span><br><span class="line">6 `position` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class="line">7 `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;,</span><br><span class="line">8 PRIMARY KEY (`id`),</span><br><span class="line">9 KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE</span><br><span class="line">10 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工记录表&#x27;;</span><br><span class="line">11</span><br><span class="line">12 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;LiLei&#x27;,22,&#x27;manager&#x27;,NOW());</span><br><span class="line">13 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;HanMeimei&#x27;,</span><br><span class="line">23,&#x27;dev&#x27;,NOW());</span><br><span class="line">14 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;Lucy&#x27;,23,&#x27;dev&#x27;,NOW());</span><br></pre></td></tr></table></figure><p><strong>1.全值匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain25.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain26.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain27.png" alt="图片"></p><p><strong>2.最左前缀法则</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;Bill&#x27; and age = 31;</span><br><span class="line">2 EXPLAIN SELECT * FROM employees WHERE age = 30 AND position = &#x27;dev&#x27;;</span><br><span class="line">3 EXPLAIN SELECT * FROM employees WHERE position = &#x27;manager&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain28.png" alt="图片"></p><p><strong>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27;;</span><br><span class="line">2 EXPLAIN SELECT * FROM employees WHERE left(name,3) = &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure><p><strong>备注：</strong><br>&lt;1&gt;. LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分。LEFT(Str,length); 接收两个参数: str:一个字符串; length:想要截取的长度,是一个正整数。<br>&lt;2&gt;.Why聚合函数索引列不能走索引?<br>答：聚合函数改变了这个列的值，不能在索引树里匹配上，所以不能走索引了。</p><p><img src="/img/mysql_explain29.png" alt="图片"><br>给hire_time增加一个普通索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ALTER TABLE `employees` ADD INDEX `idx_hire_time` (`hire_time`) USING BTREE ;</span><br><span class="line">1 EXPLAIN select * from employees where date(hire_time) =&#x27;2018‐09‐30&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain30.png" alt="图片"><br>转化为日期范围查询，有可能会走索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN select * from employees where hire_time &gt;=&#x27;2018‐09‐30 00:00:00&#x27; and hire_time &lt;=&#x27;2018‐09‐30 23:59:59&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain31.png" alt="图片"><br>还原最初索引状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ALTER TABLE `employees` DROP INDEX `idx_hire_time`;</span><br></pre></td></tr></table></figure><p><strong>4.存储引擎不能使用索引中范围条件右边的列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manage</span><br><span class="line">r&#x27;;</span><br><span class="line">2 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age &gt; 22 AND position =&#x27;manage</span><br><span class="line">r&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain32.png" alt="图片"><br><strong>现象解释</strong>：第2个sql语句name和age走了索引，position没有走索引。<br>为什么？<br>答：联合索引中，在此语句中，name列的值是确定的，age是范围查询，按索引树的有序性可以得知是可以走索引了，但是此时age字段不相等，不能保证position的有序性，所以不走索引。</p><p><strong>5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT name,age FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain33.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain34.png" alt="图片"></p><p><strong>6.mysql在使用不等于（！&#x3D;或者&lt;&gt;），not in ，not exists 的时候无法使用索引会导致全表扫描</strong><br>&lt; 小于、&gt; 大于、&lt;&#x3D;、&gt;&#x3D; 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name != &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain35.png" alt="图片"></p><p><strong>7. is null,is not null 一般情况下也无法使用索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name is null</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain36.png" alt="图片"></p><p><strong>8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name like &#x27;%Lei&#x27;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain37.png" alt="图片"><br>上图没有走索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name like &#x27;Lei%&#x27;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain38.png" alt="图片"></p><p><strong>问题</strong>：解决like’%字符串%’索引不被使用的方法？<br>a）使用覆盖索引，查询字段必须是建立覆盖索引字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT name,age,position FROM employees WHERE name like &#x27;%Lei%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain39.png" alt="图片"><br>查询字段少一点，最好是索引树内的。</p><p>b）如果不能使用覆盖索引则可能需要借助搜索引擎</p><p><strong>9.字符串不加单引号索引失效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;1000&#x27;;</span><br><span class="line">2 EXPLAIN SELECT * FROM employees WHERE name = 1000;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain40.png" alt="图片"><br>备注：被比较字段和要比较的值的类型最好相同。</p><p><strong>10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27; or name = &#x27;HanMeimei&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain41.png" alt="图片"></p><p><strong>11.范围查询优化给年龄添加单值索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ALTER TABLE `employees` ADD INDEX `idx_age` (`age`) USING BTREE ;</span><br><span class="line">1 explain select * from employees where age &gt;=1 and age &lt;=2000;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain42.png" alt="图片"><br><strong>没走索引原因</strong>：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引。<br><strong>优化方法</strong>：可以将大的范围拆分成多个小范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 explain select * from employees where age &gt;=1 and age &lt;=1000;</span><br><span class="line">2 explain select * from employees where age &gt;=1001 and age &lt;=2000;</span><br></pre></td></tr></table></figure><p><img src="/img/mysql_explain43.png" alt="图片"><br>还原最初索引状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ALTER TABLE `employees` DROP INDEX `idx_age`;</span><br></pre></td></tr></table></figure><p><strong>索引使用总结</strong>：<br><img src="/img/mysql_explain44.png" alt="图片"><br>like KK%相当于&#x3D;常量，%KK和%KK% 相当于范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ‐‐ mysql5.7关闭ONLY_FULL_GROUP_BY报错</span><br><span class="line">2 select version(), @@sql_mode;SET sql_mode=(SELECT REPLACE(@@sql_mode,&#x27;ONLY_FULL_GROUP_BY&#x27;,&#x27;&#x27;));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Explain执行计划 </category>
          
          <category> 索引 </category>
          
          <category> SQL慢查询优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Explain执行计划 </tag>
            
            <tag> 索引 </tag>
            
            <tag> mysql优化实践 </tag>
            
            <tag> B+树索引 </tag>
            
            <tag> SQL慢查询优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOM-内存溢出问题排查</title>
      <link href="/OOM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/OOM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="OOM-内存溢出的问题-排查"><a href="#OOM-内存溢出的问题-排查" class="headerlink" title="OOM(内存溢出的问题)排查"></a><strong>OOM(内存溢出的问题)排查</strong></h1><ul><li><p><strong>内存泄漏(Memory Leak)</strong>:是指程序在申请内存后,无法释放已申请的内存空间,一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。</p></li><li><p>**内存溢出(Memory Overflow)**：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p></li></ul><p><strong>OOM原因：</strong></p><p>1.一次性申请的数量太多<br>(更改申请对象数量)</p><p>2.内存资源耗尽未释放<br>(找到未释放的对象进行释放)</p><p>3.本身资源不够<br>jmap -heap 查看堆信息</p><p><strong>OOM如何定位和解决的方法</strong><br><strong>1.系统已经OOM挂了</strong></p><p>提前设置：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath= -jar xxxx.jar</span><br></pre></td></tr></table></figure><p><img src="/img/oom-1.png" alt="图片"><br>再利用Java VisualVM去分析这个文件。</p><p><strong>2.系统运行中还未OOM</strong></p><p>导出dump文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=./jvm_logs/xushu.hprof 24286</span><br></pre></td></tr></table></figure><p>注：<br>(1) file&#x3D;表示dump文件打印的位置。<br>(2)24286表示进程号。</p><p>或使用Arthas软件。</p><hr><p>线上系统OOM排查步骤：</p><ol><li>使用top命令看一下线上的CPU、内存使用情况。</li><li>定位异常进程，看日志。</li><li>如果是OOM，则用jstat -gc pid 1000 100(每秒)监控JVM内存运行情况和gc频率。</li><li>jmap -dump:live,format&#x3D;b,file&#x3D;dump3.hprof pid,<br>使用jmap dump内存快照。(导出dump文件命令)</li><li>使用MAT工具分析。<br>可以看下面的注。</li></ol><p>注：</p><ol><li><p>jps (查看进程号)</p></li><li><p>jmap -histo:live 进程号 &gt; 存放路径  (将进程打印到文本中)</p></li><li><p>start 路径名 (打开文本，查看实例个数)</p></li><li><p>ps -ef | grep 服务名 ps -aux | grep 服务名<br>查看服务的进程是否存在</p></li><li><p>查看服务的日志<br>cat -n xxx_log |grep “OutOfMemoryError”</p></li><li><p>查看堆内存占用概况<br>jmap -heap 进程号</p></li><li><p>查看堆中对象的统计信息<br>jmap -histo 进程号 | head -n 100</p></li><li><p>查看GC统计信息<br>jstat -gcutil 进程号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0 S1 E O M CCS YGC YGCT FGC FGCT GCT</span><br><span class="line">0.00 0.00 100.00 99.94 90.56 87.86 875 9.307 3223 5313.139 5322.446</span><br></pre></td></tr></table></figure><p> S0：幸存1区当前使用比例<br> S1：幸存2区当前使用比例<br> E：Eden Space（伊甸园）区使用比例<br> O：Old Gen（老年代）使用比例<br> M：元数据区使用比例<br> CCS：压缩使用比例<br> YGC：年轻代垃圾回收次数<br> FGC：老年代垃圾回收次数<br> FGCT：老年代垃圾回收消耗时间<br> GCT：垃圾回收消耗总时间</p></li><li><p><strong>生产对堆快照Heap dump</strong></p><p><strong>jmap -dump:format&#x3D;b,file&#x3D;&#x2F;tmp&#x2F;进程号_jmap_dump.hprof 进程号</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OOM </category>
          
          <category> 内存溢出 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOM </tag>
            
            <tag> 内存溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之用Stream流将List转化为Map</title>
      <link href="/JAVA%E4%B9%8B%E7%94%A8Stream%E6%B5%81%E5%B0%86List%E8%BD%AC%E5%8C%96%E4%B8%BAMap/"/>
      <url>/JAVA%E4%B9%8B%E7%94%A8Stream%E6%B5%81%E5%B0%86List%E8%BD%AC%E5%8C%96%E4%B8%BAMap/</url>
      
        <content type="html"><![CDATA[<h1 id="1、JDK1-8流方式"><a href="#1、JDK1-8流方式" class="headerlink" title="1、JDK1.8流方式"></a>1、<strong>JDK1.8流方式</strong></h1><p><strong>用户类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public User(String id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-收集成key为id，value为name："><a href="#1-收集成key为id，value为name：" class="headerlink" title="1. 收集成key为id，value为name："></a>1. <strong>收集成key为id，value为name：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class="line">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class="line">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class="line">userList.add(user1);</span><br><span class="line">userList.add(user2);</span><br><span class="line">userList.add(user3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, String&gt; next : collect.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/java-stream-1.png" alt="图片"></p><h2 id="2-收集成实体本身"><a href="#2-收集成实体本身" class="headerlink" title="2. 收集成实体本身"></a><strong>2. 收集成实体本身</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class="line">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class="line">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class="line">userList.add(user1);</span><br><span class="line">userList.add(user2);</span><br><span class="line">userList.add(user3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, user -&gt; user));</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/java-stream-2.png" alt="图片"></p><p>user -&gt; user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, User&gt; collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br></pre></td></tr></table></figure><p><strong>重复key的情况：</strong><br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, User&gt; collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());</span><br></pre></td></tr></table></figure><p>这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。<br><img src="/img/java-stream-3.png" alt="图片"></p><p><strong>toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class="line">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class="line">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class="line">userList.add(user1);</span><br><span class="line">userList.add(user2);</span><br><span class="line">userList.add(user3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2));</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/java-stream-4.png" alt="图片"></p><p><strong>这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class="line">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class="line">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class="line">userList.add(user1);</span><br><span class="line">userList.add(user2);</span><br><span class="line">userList.add(user3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;User&gt;&gt; collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, List&lt;User&gt;&gt; next : collect3.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/java-stream-5.png" alt="图片"></p><h2 id="3-指定具体收集的map"><a href="#3-指定具体收集的map" class="headerlink" title="3. 指定具体收集的map"></a><strong>3. 指定具体收集的map</strong></h2><p>toMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class="line">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class="line">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class="line">userList.add(user1);</span><br><span class="line">userList.add(user2);</span><br><span class="line">userList.add(user3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, User&gt; collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2, LinkedHashMap::new));</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, User&gt; next : collect3.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/java-stream-6.png" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> Stream流 </category>
          
          <category> List转化为Map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream流 </tag>
            
            <tag> JDK 1.8 </tag>
            
            <tag> List转化为Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地代码提交至github仓库</title>
      <link href="/%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%87%B3github%E4%BB%93%E5%BA%93/"/>
      <url>/%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%87%B3github%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="创建github账号："><a href="#创建github账号：" class="headerlink" title="创建github账号："></a>创建github账号：</h2><p>在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。</p><h2 id="创建代码仓库："><a href="#创建代码仓库：" class="headerlink" title="创建代码仓库："></a>创建代码仓库：</h2><p>在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。</p><h2 id="创建和配置密钥"><a href="#创建和配置密钥" class="headerlink" title="创建和配置密钥"></a>创建和配置密钥</h2><p>要在 Git 中创建密钥，请按照以下步骤进行操作：</p><h3 id="1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥："><a href="#1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：" class="headerlink" title="1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥："></a>1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure><h3 id="2-按回车键接受默认的文件名和位置。"><a href="#2-按回车键接受默认的文件名和位置。" class="headerlink" title="2.按回车键接受默认的文件名和位置。"></a>2.按回车键接受默认的文件名和位置。</h3><h3 id="3-输入你的密码短语（如果需要）。"><a href="#3-输入你的密码短语（如果需要）。" class="headerlink" title="3.输入你的密码短语（如果需要）。"></a>3.输入你的密码短语（如果需要）。</h3><h3 id="4-确认密码短语。"><a href="#4-确认密码短语。" class="headerlink" title="4.确认密码短语。"></a>4.确认密码短语。</h3><h3 id="5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥："><a href="#5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：" class="headerlink" title="5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥："></a>5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h3 id="6-复制你的公钥。"><a href="#6-复制你的公钥。" class="headerlink" title="6.复制你的公钥。"></a>6.复制你的公钥。</h3><h3 id="7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。"><a href="#7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。" class="headerlink" title="7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。"></a>7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。</h3><h3 id="8-点击-“Add-SSH-key”（或类似的按钮）。"><a href="#8-点击-“Add-SSH-key”（或类似的按钮）。" class="headerlink" title="8.点击 “Add SSH key”（或类似的按钮）。"></a>8.点击 “Add SSH key”（或类似的按钮）。</h3><h3 id="9-将你的公钥粘贴到-“Key”-字段中。"><a href="#9-将你的公钥粘贴到-“Key”-字段中。" class="headerlink" title="9.将你的公钥粘贴到 “Key” 字段中。"></a>9.将你的公钥粘贴到 “Key” 字段中。</h3><h3 id="10-输入一个描述性的标题以标识此密钥。"><a href="#10-输入一个描述性的标题以标识此密钥。" class="headerlink" title="10.输入一个描述性的标题以标识此密钥。"></a>10.输入一个描述性的标题以标识此密钥。</h3><h3 id="11-点击-“Add-key”（或类似的按钮）。"><a href="#11-点击-“Add-key”（或类似的按钮）。" class="headerlink" title="11.点击 “Add key”（或类似的按钮）。"></a>11.点击 “Add key”（或类似的按钮）。</h3><p>现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。</p><h2 id="创建本地代码仓库："><a href="#创建本地代码仓库：" class="headerlink" title="创建本地代码仓库："></a>创建本地代码仓库：</h2><p>在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这将在该文件夹中创建一个新的Git仓库。</p><h2 id="添加文件到本地代码仓库（更新）："><a href="#添加文件到本地代码仓库（更新）：" class="headerlink" title="*添加文件到本地代码仓库（更新）："></a>*添加文件到本地代码仓库（更新）：</h2><p>将新文件添加到本地代码仓库中。在终端中，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>这将把hello-world.py文件添加到Git的暂存区。</p><h2 id="提交（更新）："><a href="#提交（更新）：" class="headerlink" title="*提交（更新）："></a>*提交（更新）：</h2><p>提交更改描述。在终端中，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure><p>这将提交文件更改，并把提交描述设置为“Initial commit”。</p><h2 id="建立本地仓库和github仓库的关联："><a href="#建立本地仓库和github仓库的关联：" class="headerlink" title="建立本地仓库和github仓库的关联："></a>建立本地仓库和github仓库的关联：</h2><p>在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [仓库的URL地址]</span><br></pre></td></tr></table></figure><p>这将将您的本地仓库与Github仓库关联起来。</p><h2 id="推送代码到github仓库（更新）："><a href="#推送代码到github仓库（更新）：" class="headerlink" title="*推送代码到github仓库（更新）："></a>*推送代码到github仓库（更新）：</h2><p>推送您的代码到Github仓库。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。</p><p>完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。</p>]]></content>
      
      
      <categories>
          
          <category> github仓库 </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github仓库 </tag>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
            <tag> 本地代码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
